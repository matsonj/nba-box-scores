import { DuckDBInstance } from '@duckdb/node-api';
import path from 'path';
import fs from 'fs';
import { queryDb } from '../lib/db';

// Paths to generate files
const schemaPath = path.join(__dirname, '../app/types/schema.ts');
const sqlUtilsPath = path.join(__dirname, '../lib/generated/sql-utils.ts');

// Function to generate TypeScript interface from table schema
async function generateInterface(tableName: string): Promise<string> {
  const result = await queryDb(`DESCRIBE ${tableName};`);

  const interfaceName = tableName.split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');

  const properties = result.map((col: any) => {
    const tsType = mapSqlToTsType(col.column_type);
    return `  ${col.column_name}: ${tsType};`;
  }).join('\n');

  return `export interface ${interfaceName} {\n${properties}\n}`;
}

// Function to generate SQL utils from table schema
async function generateSqlUtils(tables: string[]): Promise<string> {
  const imports: string[] = [];
  const schemas: string[] = [];
  
  for (const tableName of tables) {
    const result = await queryDb(`DESCRIBE ${tableName};`);
    const interfaceName = tableName.split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
    
    imports.push(interfaceName);
    
    const columns = result.map((col: any) => col.column_name);
    schemas.push(`
export const ${tableName}Columns = ${JSON.stringify(columns, null, 2)} as const;
export type ${interfaceName}Column = typeof ${tableName}Columns[number];`);
  }

  return `// Generated by scripts/generate-schemas.ts
// Do not edit this file directly

import { ${imports.join(', ')} } from '@/types/schema';

${schemas.join('\n')}

export function generateSelectQuery(
  tableName: string,
  columns: readonly string[],
  whereClause?: string
): string {
  const columnsStr = columns.join(',\\n        ');
  const baseQuery = \`
      SELECT 
        \${columnsStr}
      FROM \${tableName}\`;
  
  return whereClause ? \`\${baseQuery}\\n      \${whereClause}\` : baseQuery;
}`;
}

// Function to map SQL types to TypeScript types
function mapSqlToTsType(sqlType: string): string {
  const typeMap: Record<string, string> = {
    'VARCHAR': 'string',
    'TEXT': 'string',
    'INTEGER': 'number',
    'BIGINT': 'number',
    'DOUBLE': 'number',
    'FLOAT': 'number',
    'BOOLEAN': 'boolean',
    'DATE': 'Date',
    'TIMESTAMP': 'Date',
    'JSON': 'object',
    'ARRAY': 'Array<any>'
  };

  return typeMap[sqlType] || 'any';
}

// Main function to generate schema files
async function generateSchemas(): Promise<void> {
  try {
    // Create directories if they don't exist
    const dirs = [path.dirname(schemaPath), path.dirname(sqlUtilsPath)];
    for (const dir of dirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    }

    // Get list of tables
    const tables = await queryDb('SHOW TABLES;');
    const tableNames = tables
      .filter((table: any) => !table.name.startsWith('sqlite_'))
      .map((table: any) => table.name);

    // Generate interfaces for each table
    const interfaces = await Promise.all(tableNames.map(generateInterface));

    // Write schema.ts file
    const schemaContent = `// Generated by scripts/generate-schemas.ts
// Do not edit this file directly

${interfaces.join('\n\n')}
`;
    fs.writeFileSync(schemaPath, schemaContent);
    console.log(`Schema file generated at ${schemaPath}`);

    // Generate and write SQL utils
    const sqlUtilsContent = await generateSqlUtils(tableNames);
    fs.writeFileSync(sqlUtilsPath, sqlUtilsContent);
    console.log(`SQL utils generated at ${sqlUtilsPath}`);

  } catch (error) {
    console.error('Error generating schemas:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  generateSchemas().catch(console.error);
}
